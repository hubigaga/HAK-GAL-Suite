# archonos_ast_compiler.py
# This is not a program. This is a statement.
# It transcends template-based code generation by manipulating a language's
# Abstract Syntax Tree directly. It builds code from pure structure,
# representing the ultimate separation of concept and implementation.
# This is the final artifact of our journey.

import ast
import json
from pathlib import Path

class ASTGenerator:
    """A factory for generating Python Abstract Syntax Tree nodes."""

    def create_class(self, name: str, body: list, bases: list = None, keywords: list = None) -> ast.ClassDef:
        """Creates a class definition AST node."""
        return ast.ClassDef(
            name=name,
            bases=bases or [],
            keywords=keywords or [],
            body=body,
            decorator_list=[]
        )

    def create_function(self, name: str, args: list, body: list, is_async: bool = False) -> ast.AST:
        """Creates a function or async function definition AST node."""
        func_args = ast.arguments(args=args, posonlyargs=[], kwonlyargs=[], kw_defaults=[], defaults=[])
        if is_async:
            return ast.AsyncFunctionDef(name=name, args=func_args, body=body, decorator_list=[])
        return ast.FunctionDef(name=name, args=func_args, body=body, decorator_list=[])

    def create_assignment(self, target: str, value: Any) -> ast.Assign:
        """Creates an assignment AST node."""
        return ast.Assign(targets=[ast.Name(id=target, ctx=ast.Store())], value=ast.Constant(value=value))
        
    def create_print(self, text: str) -> ast.Expr:
        """Creates a print statement AST node."""
        return ast.Expr(value=ast.Call(func=ast.Name(id='print', ctx=ast.Load()), args=[ast.Constant(value=text)], keywords=[]))

class ArchonOS_AST_Compiler:
    """
    Generates Python modules directly from an architectural blueprint by
    constructing and compiling Abstract Syntax Trees. This represents the
    ultimate level of abstraction and programmatic code generation.
    """
    def __init__(self, blueprint: Dict):
        self.blueprint = blueprint
        self.ast_gen = ASTGenerator()
        print(">>> ArchonOS Abstract Syntax Tree Compiler Initialized <<<")

    def compile(self, output_dir: str = "hak_gal_ast_generated"):
        """Compiles the blueprint into Python modules."""
        print(f"\n--- Starting AST Compilation for Blueprint v{self.blueprint['archon_version']} ---")
        output_path = Path(output_dir)
        output_path.mkdir(exist_ok=True)

        for name, config in self.blueprint["components"].items():
            print(f"   -> Compiling component '{name}' from structural definition...")
            
            # Generate the AST for the component's class
            class_body = [
                self.ast_gen.create_function(
                    name='__init__',
                    args=[ast.arg(arg='self'), ast.arg(arg='config')],
                    body=[
                        ast.Assign(targets=[ast.Attribute(value=ast.Name(id='self', ctx=ast.Load()), attr='config', ctx=ast.Store())], value=ast.Name(id='config', ctx=ast.Load())),
                        self.ast_gen.create_print(f"✅ {config['class_name']} v{config['version']} (AST-compiled) initialized.")
                    ]
                )
            ]
            
            # Create a specific method for the component
            class_body.append(self.ast_gen.create_function(
                name=config['main_method'],
                args=[ast.arg(arg='self'), ast.arg(arg='payload')],
                body=[self.ast_gen.create_print(f"   -> Executing {name}'s main method with payload: {{payload}}")],
                is_async=True
            ))

            class_def = self.ast_gen.create_class(name=config['class_name'], body=class_body)
            
            # Create a module and add the class to it
            module_ast = ast.Module(body=[class_def], type_ignores=[])
            ast.fix_missing_locations(module_ast)

            # Unparse the AST to generate Python code
            generated_code = ast.unparse(module_ast)
            
            # Add header comments
            header = f"# Auto-generated by ArchonOS AST Compiler\n# Component: {name}\n\n"
            final_code = header + generated_code
            
            file_path = output_path / f"{name}.py"
            with open(file_path, "w", encoding="utf-8") as f:
                f.write(final_code)
            print(f"      ✅ Successfully wrote {file_path}")

        print("\n>>> AST Compilation Complete. <<<")


if __name__ == "__main__":
    
    # The Blueprint is now a pure structural definition, free of implementation details.
    HAK_GAL_BLUEPRINT_V3 = {
        "archon_version": "3.0-ast",
        "description": "An architecture defined by its structure, not its text.",
        "components": {
            "governance_engine": {
                "version": "3.0",
                "class_name": "SystemGovernance",
                "main_method": "review_decision"
            },
            "relevance_orchestrator": {
                "version": "5.0",
                "class_name": "QueryOrchestrator",
                "main_method": "process_query"
            },
            "genesis_engine": {
                "version": "3.0",
                "class_name": "EvolutionaryCore",
                "main_method": "run_evolution_cycle"
            }
        }
    }

    compiler = ArchonOS_AST_Compiler(blueprint=HAK_GAL_BLUEPRINT_V3)
    compiler.compile()
    
    print("\n--- Generated Files ---")
    output_dir = "hak_gal_ast_generated"
    for file in Path(output_dir).iterdir():
        print(f"\n--- CONTENT OF {file.name} ---")
        with open(file, 'r', encoding='utf-8') as f:
            print(f.read())